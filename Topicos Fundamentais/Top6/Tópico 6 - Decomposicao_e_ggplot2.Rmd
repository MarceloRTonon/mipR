---
title: "Tópico 6 - Visualizando resultados de Decomposições Estruturais no ggplot2"
author: "Marcelo Tonon e Felipe Cornelio"
date: "29/09/2020"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(eval = T, include = TRUE, warning = F)
# Todos os chunks em que estiver escrito "MT" quer dizer = Mensagem do Tonon. É um quadro dando dicas e etc... Use r = Mensagem do Felipe.
```

```{r MTcronograma_tonon, eval = F, include=F}

# O que eu penso em fazer para este topico é fazer uma decomposição aditiva, uma multiplicativa e uma com a decomposição da matriz de leontief. Vou repetir o exemplo do Dietzenbacher, Lahr e Los (2004) para 2010-2015 só que também focando na aditiva. Assim os passos serão:

# 1- Baixar os arquivos (pois é o primeiro)
# 2- Int
```

## Pacotes Necessários

```{r, warning=FALSE}
library(ggplot2)
library(readxl)
library(purrr)
library(stringr)
```


## Objetivos do Tópico

Esse tópico irá introduzir tanto o tópico de análise de decomposição estrutural quanto introduzir o uso do pacote `ggplot2` para a criação de gráficos. 

Para a parte de decomposição estrutural, a bibliografia utilizada será o capitulo 13 do livro de Miller e Blair(2009), bem como os artigos de Dietzenbacher e Los (1998) e Dietzenbahcer, Lahr e Los (2004).

Para a parte de criação de gráficos com o `ggplot2` a bibliografia utilizada será o 

**Importante:** Ambos os temas são de tal profundidade que este material não poderia nem presumir esgotar ambos os tópicos.

## Dados Necessários

Para realizar uma decomposição estrutural é necessário que as bases sejam compátiveis na sua estrutura em termos de linhas e colunas. No nosso caso, nós iremos comparar as bases de 2010 e 2015 com 12 setores cada uma.

Criando arquivos temporários^[A vantagem de arquivos temporários é que eles não ficam permanentemente gravados no seu disco rígido. Para arquivos pequenos como os que estamos tratando, é bastante vantajoso.] para servirem de parametros em `destfile`:

```{r}
mip2010 <- tempfile(fileext = ".xls")
mip2015 <- tempfile(fileext = ".xls")
tbru <- tempfile(fileext = ".zip")
```

Definindo os links a serem baixados:^[Importante: Para diminuir a poluição visual na hora da leitura, este arquivo está configurado para ignorar os `warnings` dados pelo R. Assim, ao reproduzir esta e outras partes deste tópico você pode se deparar com `warnings` referentes a esta questão. A exceção é a função `read_xls` que sempre avisa quando cria novos nomes.]

```{r}
link_2010 <- "ftp://ftp.ibge.gov.br/Contas_Nacionais/Matriz_de_Insumo_Produto/2010/Matriz_de_Insumo_Produto_2010_Nivel_12_20161019.xls"

link_2015 <- "ftp://ftp.ibge.gov.br/Contas_Nacionais/Matriz_de_Insumo_Produto/2015/Matriz_de_Insumo_Produto_2015_Nivel_12.xls"

link_tbru <- "ftp://ftp.ibge.gov.br/Contas_Nacionais/Sistema_de_Contas_Nacionais/2015/tabelas_xls/tabelas_de_recursos_e_usos/nivel_12_2000_2015_xls.zip"
```

Baixando os arquivos sendo os arquivos temporarios os arquivos destino:

```{r}
download.file(url = link_2010, destfile = mip2010, mode = "wb")
download.file(url = link_2015, destfile = mip2015, mode = "wb")
download.file(url = link_tbru, destfile = tbru, mode = "wb")
```

Vamos ler com `readxl::read_xls` as partes que nos interessam dos arquivos de matriz insumo produto baixados. Vejamos a relação destes abaixo:

| **Nome do objeto** | **Descrição**                                               | **Aba** | **range**  |
|--------|---------------------------------------------------------|-----|--------|
| `nomesSetores`  | Nomes dos Setores                                       | 01  | <span style="color: green;"> "B6:B17" </span> |
| `Bn`     | Matriz dos Coeficientes Técnicos dos Insumos Nacionais  | 11  | <span style="color: green;"> "C6:N17" </span> |
| `Bm`     | Matriz dos Coeficientes Técnicos dos Insumos Importados | 12  | <span style="color: green;"> "C6:N17" </span> |
| `D_MS`   | Matriz de Market Share                                  | 13  | <span style="color: green;"> "C6:N17" </span> |
| `f_p`    | Demanda final ao nivel do produto                       | 03  | <span style="color: green;"> "V6:V17" </span> |

Vamos primeiro carregar os nomes dos setores:

```{r}
nomesSetores <- read_xls(mip2010, sheet = "01", range = "B6:B17", col_names = "Setores")

```

Vamos criar agora listas com os parametros de cada elementos:

```{r}
mipElements <- list("Bn", "Bm", "D_MS", "f_p")


nomesSetores <- list(nomesSetores$Setores, 
                     nomesSetores$Setores,
                     nomesSetores$Setores,
                     "Total") %>%
  setNames(mipElements)

mipRanges <- list("C6:N17", "C6:N17", "C6:N17", "V6:V17") %>%
  setNames(mipElements)

mipAbas <- list("11", "12", "13", "03")  %>%
  setNames(mipElements)
```

Vamos agora criar uma lista para cada ano:

```{r}
matrizes2010 <- list(mipAbas, mipRanges, nomesSetores) %>%
  pmap(function(x,y,z) readxl::read_xls(path = mip2010,
                                        sheet = x,
                                        range = y,
                                        col_names = z)) %>%
  map(as.matrix)

matrizes2015 <- list(mipAbas, mipRanges, nomesSetores) %>%
  pmap(function(x,y,z) readxl::read_xls(path = mip2015,
                                        sheet = x,
                                        range = y,
                                        col_names = z)) %>%
  map(as.matrix)
```

Vamos agora tratar das Tabelas de Recursos e Usos. Nós desejamos retirar os seguintes elementos delas:

| Nome do Objeto | Descrição                                           | tipo de arquivo | aba | range   |
|----------------|-----------------------------------------------------|-----------------|-----|---------|
| `valorAd`        | Total de valor adicionado gerado em cada atividade  | tab2            | VA  | <span style="color: green;"> "B6:M6" </span>   |
| `W`              | Total de Salário gerado em cada atividade           | tab2            | VA  | <span style="color: green;"> "B8:M8" </span>   |
| `fatorL`         | Total do Fator Trabalho demandado em cada atividade | tab2            | VA  | <span style="color: green;"> "B19:M19" </span> |


Criando os parâmetros:

```{r}
truElements <- list("valorAd", "W", "fatorL")

truRange <- list("B6:M6", "B8:M8", "B19:M19") %>%
  setNames(truElements)
```

O arquivo `tbru` é um arquivo `zip` que contém vários arquivos, muito dos quais não nos interessam. Como já abordamos no tópico 5, vamos descompactar apenas os arquivos que nos interessam, que são os que contém a descrição `tab2` e são de 2010 e 2015:

```{r}
tab2_arquivos <-  tbru %>%
  unzip(list = T) %>%
  unlist %>%
  stringr::str_subset("tab2")
```

Vamos criar uma função que nos possibilite mais facilmente descompactar um arquivo do vetor `tab2_arquivos` diretamente apenas indicando o ano que queremos baixar.

```{r}
unzip_tab2 <- function(ano){
  .tab2_dir <- tempfile()
  
 .tab2_output <-  tab2_arquivos %>%
  stringr::str_subset(paste0("tab2_", ano, ".xls")) %>%
  unzip(zipfile = tbru,
        files = .,
        junkpaths = F,
        exdir = .tab2_dir)  
 return(.tab2_output)
}
```

Vamos então carregar para os dois anos em questão:

```{r}
tab2_2010 <- map(truRange, ~ read_xls(unzip_tab2("2010"),
                       sheet = "VA",
                       range = .x,
                       col_names = nomesSetores$Bn)
    ) %>%
  map(as.matrix)
  
tab2_2015 <-  map(truRange, 
                  ~ read_xls(unzip_tab2("2015"),
                    sheet = "VA",
                    range = .x,
                    col_names = nomesSetores$Bn)
    ) %>%
  map(as.matrix)
```

### Deflacionando os valores

Importante: nesse caso, os valores não estão deflacionados. Por isso precisamos deflacionar os valores. Como discutido durante o curso, existem várias formas de você fazer uma deflação de preços. Por questões de simplicidade, vamos usar aqui um deflator único. Para tanto, vamos comparar os valores correntes e do ano anterior da produção total da economia. Esses valores está disponivel na célula `O19` da aba `producao` das tabelas 1 (valores correntes) e 3 (valores do ano anterior).

```{r}
tab_arquivos <- function(tab){
  .tab <- tbru %>%
    unzip(list = T) %>%
    unlist %>%
    stringr::str_subset(paste0(tab, "_", 201)) %>%
    as.list()
  return(.tab)
}

deflatorY2Y <- function(Corrente, Anterior){

  fileCor <- tempfile(fileext = ".xls")
  fileAnt <- tempfile(fileext = ".xls")

  unziptab <- function(x,y){
    unzip(zipfile = tbru,
        files = x,
        junkpaths = F,
        exdir = y,
        overwrite = T)
  }
  
  .Cor <- read_xls(path = unziptab(Corrente, fileCor),
                   sheet = "producao",
                   range = "O19",
                   col_names = "Total") %>%
    unlist()
  
  .Ant <- read_xls(path = unziptab(Anterior, fileAnt),
                   sheet = "producao",
                   range = "O19",
                   col_names = "Total") %>%
    unlist()
    
    return(.Cor/.Ant)
}

deflatores_Ano_a_Ano <- map2(tab_arquivos("tab1"),
                             tab_arquivos("tab3"),
                             deflatorY2Y)
```

Para gerar um deflator direto de 2010 a 2015, multiplicamos todos os deflatores de 2011 à 2015  (o deflator de 2010 é referente a deflação de preços de 2010 frente à 2009, por isso iremos exclui-lo). Para tanto, vamos usar a função `purrr::reduce` do pacote purrr.

```{r}
deflator <- deflatores_Ano_a_Ano[-1] %>%
  reduce(`*`)
```

Agora, vamos deflacionar os valores que devem ser deflacionados:

```{r}
matrizes2015$f_p <- matrizes2015$f_p/deflator

tab2_2015$valorAd <- tab2_2015$valorAd/deflator
tab2_2015$W <- tab2_2015$W/deflator
```

Agora temos todos os nossos valores prontos para realizar uma decomposição.


## Análise de Decomposição Estrutural

**Atenção:** a parte a seguir vamos deixar as contas mais simples ocultar. É sugerido que se pegue um papel e caneta e faça as contas por si só.

A análise de decomposição estrutural ( _Structural Decomposition Analisys: SDA_) é uma forma de se decompor os motivos de uma diferença entre dois períodos ou regiões de um determinado valor.

Por exemplo, sejam $X_0$ e $X_1$ os valores bruto de produção dos períodos 0 e 1, que são dados a partir do modelo básico de Leontief:

$$X = L f$$
```{r}
matrizes2010$An <- matrizes2010$D_MS %*% matrizes2010$Bn
matrizes2010$Leontief <- solve(diag(nrow(matrizes2010$An)) - matrizes2010$An)
matrizes2010$f <- matrizes2010$D_MS %*% matrizes2010$f_p
matrizes2010$X <- matrizes2010$Leontief %*% matrizes2010$f

matrizes2015$An <- matrizes2015$D_MS %*% matrizes2015$Bn
matrizes2015$Leontief <- solve(diag(nrow(matrizes2015$An)) -     matrizes2015$An)
matrizes2015$f <- matrizes2015$D_MS %*% matrizes2015$f_p
matrizes2015$X <- matrizes2015$Leontief %*% matrizes2015$f

```

Sendo $L$ a inversa de Leontief e $f$ o vetor de demanda final. A definição de $X_0$ é $X_1$ é, respectivamente $X_0 = L_0f_0$ e $X_1 = L_1 f_1$. Desse modo, queremos agora saber qual foi a contribuição das variações tanto de $L$ quanto de $f$ para a variação final em $X$. Temos então que:

$$\Delta X = X_1 - X_0 = L_1f_1 - L_0f_0$$

```{r}
deltaX <- matrizes2015$X - matrizes2010$X
```


Seja $\Delta L = L_1 - L0$ e $\Delta f = f_1 - f_0$, podemos substituir na equação acima os valores de modo:

$$\Delta X = L_1 (f_0 + \Delta f) - (L_1 - \Delta L) f_0 = \Delta L f_0 + L_1(\Delta f)$$
```{r}
deltaL <- matrizes2015$Leontief - matrizes2010$Leontief
deltaf <- matrizes2015$f - matrizes2010$f
```

```{r}
deltaX1 <- (deltaL %*% matrizes2010$f) + (matrizes2015$Leontief %*% deltaf)

all.equal(deltaX1, deltaX)
```

Podemos no entanto, redistribuir isso de outra forma:

$$\Delta X = (L_0 + \Delta L) f_1 - L_0(f_1 -  \Delta f) = (\Delta L)f_1 + L_0 (\Delta f)$$

```{r}
deltaX2 <- (deltaL %*% matrizes2015$f) + (matrizes2010$Leontief %*% deltaf)

all.equal(deltaX2, deltaX)
```

_Relembrando:_ Para ter certeza que compreendeu a álgebra, faça essas substituições e operações no papel.

Ambas as formas apresentadas agora são igualmente válidas, sendo ambas igualmente corretas.

```{r}
all.equal(deltaX1, deltaX2)
```

 No entanto, é de certo modo obvio que esperamos que $(\Delta L)f_1 \neq (\Delta L) f_0 $.

```{r}
all.equal(deltaL %*% matrizes2010$f,
          deltaL %*% matrizes2015$f)
```


Dietzenbacher e Los (1998), mostram que ao tirarmos os valores médios das adições aditivas temos um resultado aceitável:

$$\Delta X = (1/2) \Delta L (f_0 + f_1) + (1/2) (L_1 + L_2) \Delta f $$

```{r}
deltaX3 <- ((1/2) *deltaL %*% (matrizes2010$f + matrizes2015$f)) +
  ((1/2)*(matrizes2010$Leontief + matrizes2015$Leontief) %*% deltaf)

all.equal(deltaX, deltaX3)
```

Na equação acima, temos que a parcela $(1/2) \Delta L (f_0 + f_1)$ é referente a mudança tecnológica enquanto $(1/2) (L_1 + L_2) \Delta f$ é referente a mudanças na demadna final

## ggplot2

## Bibliografia usada neste material

### Análise de Decomposição Estrutural

DIETZENBACHER, Erik; LAHR, Michael L.; LOS, Bart. The decline in labor compensation’s share of GDP: a structural decomposition analysis for the United States, 1982 to 1997. Wassily Leontief and Input-Output Economics, p. 138-185, 2004.

DIETZENBACHER, Erik; LOS, Bart. Structural decomposition techniques: sense and sensitivity. Economic Systems Research, v. 10, n. 4, p. 307-324, 1998.

MILLER, Ronald E.; BLAIR, Peter D. Input-output analysis: foundations and extensions. Cambridge university press, 2009.

### ggplot2

WICKHAM, Hadley. ggplot2: elegant graphics for data analysis. springer, 2016.


## Bibliografia extra indicada