---
title: "Tópico 3 - Subsetting pelo tidyverse"
author: "Marcelo Tonon e Felipe Cornelio"
date: "17/06/2020"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```


## Instalando o Tidyverse

Como iremos tratar de muitos pacotes dentro do *tidyverse*, vale baixar a familia de pacote como um todo. Por ser muito grande, pode demorar um tempo, então sugiro que se vocês ainda não estiverem instalado eles, que o façam logo se vocês ainda não tiverem a familia instalada. Se você tiver que instala-lo, você pode esperar isso enquanto:

  1. Ir no banheiro ou lavar ao menos parte da louça enquanto escuto o Podcast do IE;
  2. Ler o resto do Tópico, enquanto espera o R instalar o tidyverse.

```{r, eval = FALSE}
install.packages("tidyverse")
```

A vantagem de assinalar o `tidyverse` é que o R irá baixar e instalar todos os pacotes do tidyverse. Ao usar `library(tidyverse)`, todos os pacotes do *"nucleo duro"* do `tidyverse` são carregados. Repare que se você instalou o `tidyverse` inteiro, ele irá carregar o `dplyr` e o`tidyr`^[O inverso não seria verdadeiro por outro lado. A instalação do `dplyr` não garante a instalação do resto da do resto dos pacotes.].


```{r}
#Carregando o tidyverse inteiro
#library(tidyverse)

#Carregando só os pacotes que iremos precisar.
library(dplyr)
library(tidyr)
```


A familia de pacotes do `tidyverse` fortalece bastante a análise e manipulação de dados no R, especialmente para bases de dados retangulares e mais ainda para bases *tidy*. Vale notar, que este não é o caso de Matrizes Insumo Produto (que no geral são bases de dados quadradas), porém além de várias funcionalidades uteis como um todo, além do maravilhoso pacote *purrr* que veremos no Tópico sobre automatizar as tarefas.

Os pacotes do núcleo duro do *tidyverse* são:

- ***tibble***: Já falamos, brevemente, desse pacote no Tópico 2. Um `tibble` é como um `data.frame` só que, na propria definição do site do [`tidyverse`](https://tibble.tidyverse.org/), mais preguiçoso e ranzinza. Ele não facilita sua vida como o `data.frame` o faz. Por exemplo, ele não muda nem o nome nem o tipo das variáveis e irão reclamar mais. Importante notar que antes um `tibble` e um `data.frame` eram mais diferentes do que são hoje^[Até agora (Junho de 2020) nem o [site](https://tibble.tidyverse.org/) nem a documentação do `tibble` no R foram atualizadas nesse sentido.], pois a função `data.frame` por default convertia `strings` em `factor`, o que mudou na atualização 4.0.0 do R.^[Veja mais na documentação de `data.frame`, em especial no argumento de `stringAsFactors`.] A principio, o `tibble` não será mais abordado aqui no curso, (pelo fato de que teremos um ) assim que desejar se aprofundar mais nele pode conferir o capitulo 10 do [*R for Data Science*](https://r4ds.had.co.nz/tibbles.html) e [neste artigo](https://tibble.tidyverse.org/articles/tibble.html).

- ***readr***: No tópico 2, também já falamos sobre o pacote `readr`, e como ele é muito mais rápido que o `base` R para importar uma base de dados. É importante considerar apenas que ele importa a base como um `tibble` e não um `data.frame`.

- ***dplyr***:  https://dplyr.tidyverse.org/

- ***tidyr***: https://tidyr.tidyverse.org/

- ***purrr***:

- ***stringr***:

- ***ggplot2***:

- ***forcats***: Este pacote é útil para lidar com `factors` (*forcats* é um anagrama de *factors*), que é uma `classe` de vetores que servem para dar categorias à um `data.frame`. `factors` já foram mais comuns no R do que são hoje, em especial após a expansão do *Tidyverse* e da versão 4.0.0 da linguagem. Um ensino detalhado sobre `factors` e como manipula-los está fora do escopo deste curso. Para quem tiver interesse, vale acessar o capitulo [15 do R for Data Science](https://r4ds.had.co.nz/factors.html) para aprender sobre o *forcats*. Para usar *factors* com um maior enfoque no base-R, vale a leitura da subseção [5.5.2](https://rstudio-education.github.io/hopr/r-objects.html#factors) do *Hands-on Programming with R*, e das subseções [3.4](https://adv-r.hadley.nz/vectors-chap.html#s3-atomic-vectors) e [4.2.1](https://adv-r.hadley.nz/subsetting.html#atomic-vectors-1) do *Advanced R*. 

Dada a natureza do *Tidyverse*, será mais usada nessa parte o operador *pipe* `%>%`, ao invés da escrita *nested*. Sempre que você carregar algum dos Relembrando o uso dele abaixo:

```{r, eval = FALSE}
#Modo Nested
objeto2 <- funcao3(funcao2(funcao1(objeto1)))


#Modo Pipe
objeto2 <- objeto1 %>% funcao1() %>% funcao2() %>% funcao3()
```

Ou seja, ao invés de uma escrita que vai de dentro (`objeto1`) para fora (`funcao3`) como no modo *nested*, você tem uma escrita da esquerda (`objeto1`) para a direita (`funcao3`). Veja alguns exemplos abaixo:

```{r, eval = FALSE}
# mtcars é uma base de dados interna do R usada para dar exemplos. 

#calcular a media de cada coluna usando colMeans

#modo nested
means_mtcars <- colMeans(mtcars)

# modo pipe %>%
means_mtcars <- mtcars %>% colMeans

#modo_nested
colMeans(mtcars)[5]

# modo pipe %>%
mtcars %>% colMeans %>% .[5]

# Há também o operador %$%, dentro do pacote magrittr também do tidyverse
library(magrittr)
mtcars %>% colnames() %>% .[5]
mtcars %$% drat %>% mean()

# Repare que ao usar %$% não é necessario usar "" para ser referir ao nome das colunas! 
```

Quanto mais longo a linha de comando, melhor será aplicar o modo *pipe* em detrimento do *nested*. Além disso, repare que `%$%` equivale as duas chaves `mtcars[["drat"]]`.

## Subsetting com o Tidyverse

### Extraindo colunas a partir dos seus nomes

Existe duas funções para você retirar colunas a partir dos seus nomes, `select` e `pull`. O `select` irá manter a estrutura de dados, enquanto `pull` irá alocar todos os dados selecionados  num vetor atómico. Veja os exemplos abaixo:

```{r, eval = FALSE}
# Selecionando apenas a coluna 5
selExemplo1 <- select(mtcars, 5)
pullExemplo1 <- pull(mtcars, 5)

# Selecionando as colunas 1,3,7

selExemplo2 <- mtcars %>% select(c(1,3,7))
pullExemplo2 <- mtcars %>% pull(c(1,3,7))
# Excluindo as colunas 1,3,7

selExemplo3 <- mtcars %>% select( -c(1, 3, 7))
pullExemplo3 <- mtcars %>% pull(-c(1, 3, 7))

# Selecionando a primeira coluna pelo nome:

selExemplo4 <- mtcars %>% select(mpg)
pullExemplo4 <- mtcars %>% pull(mpg)

# Excluindo a primeira coluna pelo nome:

selExemplo5 <- mtcars %>% select(-mpg)
pullExemplo5 <- mtcars %>% pull(-mpg)
```

Os exemplos acima fazem de forma bastante similar aquilo que o base R também faz. Porém, existem os `select_helpers` que são muito uteis para usar na função `select` em especifico. Veja alguns abaixo:

```{r}
# starts_with
selExemplo6 <- mtcars %>% select( starts_with("m"))

# ends_with
selExemplo7 <- mtcars %>% select(ends_with("t"))

# contains
selExemplo8 <- mtcars %>% select(contains("s"))

# matches (ignora se é maiusculo ou minusculo)
selExemplo9 <- mtcars %>% select(matches("MPG"))
```

Existem outros elementos que fazem parte dos `select_helpers` se você quiser saber mais.

### Linhas

No que tange o subsetting via as linhas, temos três funções relevantes: `filter`, `distinct` e `arrange`.

#### filter

A função `filter` irá filtrar as linhas a partir de uma condição. Que fique claro, quando falarmos abaixo em *filtrar* determinadas linhas, é que apenas essas linhas serão selecionadas. Você pode usar e abusar das comparações lógicas ( `==`, `!=`,  `>`, `>=`, `<`, `<=`). Veja os exemplos abaixo para usar `filter` com apenas uma condição e repare que a ordem dos argumentos não importa:

```{r}


# Filtrando as linhas cuja os valores da coluna Plant seja iguais a "Qn1".
CO2 %>% filter(Plant == "Qn1")
#CO2 %>% filter("Qn1" == Plant)


# Filtrando as linhas cuja os valores da coluna Plant seja iguais a "Qn1" e "Mn1".

#CO2 %>% filter(Plant == c("Qn1", "Mn1"))
CO2 %>% filter(c("Qn1", "Mn1") == Plant)

# Usando filter em sequência:
# Pt1: Filtrando as linhas cuja os valores da coluna Plant seja diferente de "Qn1".
# Pt2: Filtrando depois os valores da coluna Treatment sejam iguais à "chilled".

#CO2 %>% filter("Qn1" != Plant) %>% filter(Treatment == "chilled")
CO2 %>% filter(Plant != "Qn1") %>% filter("chilled" == Treatment)

# Filtrando as linhas que o valor de `conc` seja maior que 250.

#CO2 %>% filter(conc > 250)
CO2 %>% filter(250 < 250)

# Filtrando as linhas que o valor de `uptake` seja menor ou igual a 10

#CO2 %>% filter(10 >= uptake)
CO2 %>% filter(uptake <= 10)
```

Repare que a ordem que você escreve os elementos a serem comparados não alteram o funcionamento da função. Você pode então Você pode deixa o uso de `filter` muito mais complexo. Veja abaixo um exemplo com as funções `mean`, `median` e moda^[Feita a partir deste código: https://www.tutorialspoint.com/r/r_mean_median_mode.htm]:

```{r}
CO2 %>% filter(conc > mean(conc))

CO2 %>% filter(uptake <= median(uptake))

# Criando a função moda:
moda <-  function(v) {
   uniqv <- unique(v)
   uniqv[which.max(tabulate(match(v, uniqv)))]
}

CO2 %>% filter(conc == moda(conc))
```

Podemos colocar mais de uma condição em `filter` para não ter que fazer uma sequência. Veja abaixo:

```{r}
#Ao invés de:
#CO2 %>% filter(conc == moda(conc)) %>% filter(uptake <= median(uptake))

#Você pode fazer:

CO2 %>% filter(conc ==moda(conc), uptake <= median(uptake))
```

No caso acima foram selecionadas as linhas que ao mesmo tempo eram iguais à moda da coluna `conc` e eram menores que a  mediana de `uptake`. Poderiamos ir além e colocar um terceiro elemento:

```{r}
CO2 %>% filter(conc ==moda(conc), uptake <= median(uptake), Treatment == "chilled")
```


Já tratamos do uso da função `filter` com as comparações lógicas, agora vamos falar dela com os ***operadores lógicos***. O poder de filter aumenta e muito quando usamos eles, veja só:

```{r}
### Os operadores básicos: Seja A e B dois conjuntos.

# O operador A&B: interseção de A e B(ou)
# Repare que é o mesmo que: 
#CO2 %>% filter(conc ==moda(conc), uptake <= median(uptake))

CO2 %>% filter(conc ==moda(conc) & uptake <= median(uptake))

# O operador A|B: união de A e B (A e B)

CO2 %>% filter(conc == moda(conc) | uptake <= median(uptake))

# A função xor(A,B): todos elementos de A e B fora da interseção. 
#xor(A,B) = A|B - A&B. A chamada Diferença Simétrica.

CO2 %>% filter(xor(conc == moda(conc), uptake <= median(uptake)))

### Combinações entre eles:

## Exclusão de um dos elementos

# A & !B: Excluí de A tudo que é de B. Ou seja, A menos a interseção de A e B.

CO2 %>% filter(conc == moda(conc) & !uptake <= median(uptake))

# !A & B: Exclui de B tudo que é de A. Ou seja, B menos a interseção de A e B.

CO2 %>% filter(!conc == moda(conc) & uptake <= median(uptake))
```

Perceba que `filter`, como toda função do subsetting, faz nada mais que selecionar as linhas que retornam `TRUE` às condições que ele impõe. Por isso, as comporações e operações lógicas são instrumentos tão poderosos para a seleção `filter`.

Existem mais três funções que podem ser usados para aumentar a força de `filter`: `is.na()`, `between()` e `near`. A função `is.na()` confere se um valor é `NA`. Assim podemos usa-la para selecionar (ou excluir), linhas que possuam valores `NA`.

```{r}

# Checando se valores são NA.
is.na(1)
is.na(NA)

# Checando se valores de um vetor são NA ou não.
is.na(c(1,2,NA))

# Checando quais linhas tem NA da coluna Ozone da base de dados Ozone.
airquality$Ozone %>% is.na()

# filtrando as linhas que tem NA
airquality %>% filter(is.na(Ozone))

# filtrando as linhas que não tem NA (pegando as primeiras 20 linhas)
airquality %>% filter(!is.na(Ozone)) %>% .[1:20,]
```

Já a função `between` serve para você filtrar linhas que contém elementos númericos entre dois valores.

```{r}

x <- 1:7
# Testando quais elementos de x estão entre 3 e 5. (3 e 5 estão inclusos.)
dplyr::between(x, 3,5)

#Filtrando os elementos de CO2 que estão entre 100 e 200.
CO2 %>% filter(between(conc, 100, 200))
```

A função `near` funciona como `==` só que com uma margem de tolerância dada pelo argumento `tol`. Importante notar que `tol` já tem um valor `default` que é `.Machine$double.eps^0.5`. Vejamos abaixo:

```{r}
x <- c(1,2,3)
y <- c(1.4, 3, 3)

#Testando quais valores de x e y estão próximos pela tolerância default:
near(x,y)

# Vendo o valor default de tolerância:
.Machine$double.eps^0.5

# Testando se x e y estão próximos por uma tolerância de 0.5:
near(x,y,0.5)

# Filtrando as linhas com valores de uptake próximos de 40 pela tolerância default:
CO2 %>% filter(near(uptake, 40))

# Filtrando as linhas com valores de uptake próximos de 40 pela tolerância de 1:
CO2 %>% filter(near(uptake, 40, tol = 1))
 
```

##### (decidindo se farei) Variações de filter 

Existem três variações de `filter`: `filter_all`, `filter_if` e `filter_at`. Iremos explicar aqui as duas primeiras variações, pois a terceira é complexa demais para esse estágio. De todo modo, `filter_all` e `filter_if` são filtram uma base de dados aplicando um predicando a todas as variáveis. Esses predicados devem ser expostos com `all.vars()` ou `any_vars()`.

```{r}
#filtrando as linhas de airquality que algum dos seus valores for NA
# você deve usar o . para se referir as variáveis.
# Ex1: airquality %>% filter_all(any_vars(is.na()))
# Ex1 acima iria retornar um erro.
airquality %>% filter_all(any_vars(is.na(.))) %>% head()

#filtrando as linhas de airquality que TODOS os seus valores forem NA
airquality %>% filter_all(all_vars(is.na(.)))

```



#### Removendo duplicatas com distinc

A função distinct remove linhas duplicadas dos seus data.frames. Veja o exemplo abaixo:

```{r}
ex_df <- data.frame("A"=c(1,0,1,1,-0), "B" = c(0,1,0,1, 1) )
ex_df
# As linhas 1 e 3 são iguais e a 2 e 5 também. Usemos distinct para remover as duplicatas
ex_df %>% distinct()

```

#### Reordenando as linhas com arrange

A função `arrange` serve para reordenar as linhas de acordo com uma coluna. 

```{r}
# Forma crescente (menores primeiro)
iris %>% arrange(Sepal.Length) %>% head()

# Forma decrescente (maiores primeiro )
iris %>% arrange(desc(Sepal.Length)) %>% head()
```

Também é possível fazer isso em vetores `character`:

```{r}
iris %>% arrange(Species) %>% head()
```

## Arrumando os dados.

Como vocês puderam ver no Tópico 2, nem todos os dados vem como gostariamos que eles viessem. Existem problemas, que emergem quando as variáveis surgem. 




## Fontes:

Pacotes do tidyverse: https://www.tidyverse.org/packages/

R for Data Science: https://r4ds.had.co.nz/

Código para função moda: https://www.tutorialspoint.com/r/r_mean_median_mode.htm

