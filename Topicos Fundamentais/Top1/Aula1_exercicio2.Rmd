---
title: "Exercicios Extras - Aula 1 & Algebra Linear"
author: "Marcelo Tonon e Felipe Cornelio"
date: "10/06/2020"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, eval = FALSE)
```

Este material foi feito para ajudar a solidificar a primeira parte do curso. Assim faça primeiro os exercicios da aula 1 e então venha para essa lista. Olhe também a apostila de Algebra Linear para ajudar em alguns exercicios também.

Dado que essa lista é uma continuação de outros exercicios, nós vamos usar uma numeração que começa a partir do número 6.

Alguns desses exercicios são muito repetitivos. Sim eu sei. Mais a frente, parte do exercicio será refazer esses exercicios de forma automática.

## 6. Operações básicas com matrizes

#### Q.6.1 Crie as três matrizes abaixo, guardando todas elas numa lista, chamada `listaQ6.1`.

$$
\begin{pmatrix}
4&3 \\
3&2
\end{pmatrix} ;
\begin{pmatrix}
2&1 \\
5&9
\end{pmatrix};
\begin{pmatrix}
3&2&1 \\
8&2&4 \\
4&1&2
\end{pmatrix};
\begin{pmatrix}
2&1\\
0&1
\end{pmatrix}
$$

```{r, include = FALSE, eval = FALSE}

#Método extensivo.

listaQ6.1 <- list()
listaQ6.1[[1]] <- matrix(c(4,3,3,2), nrow =2)
listaQ6.1[[2]] <- matrix(c(2,5,1,9), nrow =2)
listaQ6.1[[3]] <- matrix(c(3,8,4,2,2,1,1,4,2), nrow = 3)
listaQ6.1[[4]] <- matrix(c(2,0,1,1), nrow = 2)
```

#### Q.6.2 Faça uma lista `listaQ6.2` a partir da `listaQ6.1`, com os determinantes de cada uma das matrizes.

***DICA:*** Se você estiver com problemas para mexer com as listas, lembre-se da questão **Q.3.6**.

```{r, include=FALSE, eval = FALSE}
# Método Manual-Extensivo
listaQ6.2 <- list()

listaQ6.2[[1]] <- det(listaQ6.1[[1]])
listaQ6.2[[2]] <- det(listaQ6.1[[2]])
listaQ6.2[[3]] <- det(listaQ6.1[[3]])
listaQ6.2[[4]] <- det(listaQ6.1[[4]])

# Método loop (for)
listaQ6.2 <- list()
for(i in 1:4){
  listaQ6.2[[i]] <- det(listaQ6.1[[i]])
}

# Método Funcional (purrr)
library(purrr)
listaQ6.2 <- listaQ6.1 %>% map(det)
```


#### Q.6.3 Observando os valores de `listaQ6.2`, quais matrizes, $M$, dentro de `listaQ6.1` possuem uma inversa $M^{-1}$ ? Use a função `unlist` em `listaQ6.2`. Você entende o que ele faz? Use `help` caso não.

```{r, include = FALSE, eval = FALSE}
listaQ6.2 %>% unlist
```

#### Q.6.4 Faça uma lista `listaQ6.4` com apenas as matrizes, `M`, de `listaQ6.1` que possuem inversa, $M^-1$.

```{r, eval=FALSE, include = FALSE}
#Modo manual
listaQ6.4 <- listaQ6.1[-3]
```

#### Q.6.5 Crie uma lista `listaQ6.5` com as matrizes inversas, $M^-1$, das matrizes, $M$, presentes na lista `listaQ6.4`.

```{r, include=FALSE, eval = FALSE}
#Método manual
listaQ6.5 <- list()

listaQ6.5[[1]] <- solve(listaQ6.4[[1]])
listaQ6.5[[2]] <- solve(listaQ6.4[[2]])
listaQ6.5[[3]] <- solve(listaQ6.4[[3]])

#Método loop for
listaQ6.5 <- list()
for(i in 1:3){
  listaQ6.5[[i]] <- solve(listaQ6.4[[i]])
}

#Método Purrr
listaQ6.5 <- listaQ6.4 %>% map(solve)
```


#### Q.6.6 Crie uma matriz tranposta, $M'$, de alguma matriz, $M$, da `lista.q6.4`.
#### Q.6.7 Crie uma lista `listaQ6.7` com as matrizes indicadas abaixo. 


\begin{align*}
J&=\begin{pmatrix}
1 & 2 \\
2 & 1
\end{pmatrix} \\

H&=\begin{pmatrix}
0.7  \\
0.3
\end{pmatrix}
\end{align*}


##### D.6.1 - ***Desafio:*** Veja se você consegue nomear as matrizes `"J"` e `"H"` dentro da lista. 

***Dica para D.6.1:*** Existe duas formas de vocês fazer isso. A documentação de `list` e `names` pode te ajudar nisso. A praticidade de cada uma que irá variar de situação para situação.

```{r, eval= FALSE, include = FALSE}
# Nomeando ao criar a lista:
listaQ6.7 <- list( "J" = matrix(c(1,2,2,1), nrow = 2),
                   "H" = matrix(c(0.7, 0.3), nrow = 2)
)

# Usando names:
listaQ6.7 <- list()
listaQ6.7[[1]] <- matrix(c(1,2,2,1), nrow = 2)
listaQ6.7[[2]] <- matrix(c(0.7, 0.3), nrow = 2)

names(listaQ6.7) <- c("J", "H")
```

**Dica:** Para ajudar na parte da nomes você pode acessar 

#### Q.6.8 Faça uma multiplicação de matrizes entre J e H.
```{r, include=FALSE, eval=FALSE}
# Forma [[:
listaQ6.7[[1]] %*% listaQ6.7[[2]]

# Forma $:

listaQ6.7$J %*% listaQ6.7$H
```

##### D.6.2 - ***Desafio:*** Se você conseguiu nomear as matrizes dentro das listas, há então duas formas de você extrair as matrizes da lista `listaQ6.7`. Quais são elas? Escreva a multiplicação das duas formas. 

**Dica para o D.6.2:** Procure saber sobre `Extract`, e veja os símbolos envolvidos.



### Série de desafios sobre avaliação de igualdade.

**IMPORTANTE:** Essa parte sobre avaliar se os objetos são iguais ou não, foi dada ***parcialmente*** na aula do dia 9/06/2020, e podendo ser conferida no `script Aula 1.R`. Assim, colocamos outras questões aqui, de baixissima dificuldade de resolução, porém com conhecimentos a principio vocês não têm, justamente para testar se o ***The SeViration*** passado no exercicio anterior está evoluindo. A prática da programação é muito isso em certa medida.


##### D.6.3 - ***Desafio:*** Confira se os produtos de $JH$ e $(H'J)'$ são iguais usando `==`.
```{r, include = FALSE, eval= FALSE}
t(t(listaQ6.7$H) %*% (listaQ6.7$J)) == listaQ6.7$J %*% listaQ6.7$H
```



##### D.6.4 - ***Desafio rápido:*** Olhando o resultado de D.6.3, você consegue dizer qual é o problema em usar `==` para avaliar se dois vetores são iguais como um todo? Se você não souber resolver rapidamente, **não pare**! Vá seguindo até o desafio D.6., porém a cada desafio resolvido pare e tente pensar o que seria   

```{r, include= FALSE, eval= FALSE}
cat("O problema de usar "==" em vetores é que ele avalia a igualdade célula à célula. Ou seja, você não recebe um único resultado te informando se os dois vetores são iguais.")
```

##### D.6.4 - ***Desafio:*** Teste a igualdade `2` e `1` usando `==`. E depois, com `a <- 1`, teste para `a == 1`.
```{r, include= FALSE, eval = FALSE}
2 == 1
a <- 1
a == 1
```

##### D.6.5 - *** Desafio:*** Teste a igualdade de `c(1,1,2)` e `c(1,2,1)` usando `==`.
```{r, include = FALSE, eval = FALSE}
c(1,1,2) == c(1,2,1)
```



##### D.6.6 - ***Desafio:*** Refaça o desafio D.6.3, só que ao inves de usar `==`,  use a função `all.equal` para testar se ambas . O que ela retornou? Ela é mais indicada do que `==`  para avaliar a igualdade entre dois vetores como um todo? Porque?

```{r, include = FALSE, eval = FALSE}
all.equal(t(t(listaQ6.7$H) %*% (listaQ6.7$J)), (listaQ6.7$J %*% listaQ6.7$H))
print("Sim, pois ela retorna apenas um resultado para todo o vetor e não um célula a célula.")
```

##### D.6.7 - ***Desafio:*** Refaça D.6.4 e D.6.3, só que ao invés de usar `==`, use a função `all.equal()`. O que ela retorna? Use `typeof()` nos resultados e busque entender o comportamento do valor de saída dela comparando com o de `==` para as mesmas variáveis.

```{r, include= FALSE, eval = FALSE}
all.equal(2, 1)
2==1
typeof(all.equal(2,1))
typeof(2==1)

a <- 1
all.equal(a, 1)
a ==1

typeof(all.equal(a,1))
typeof(a ==1)

all.equal(c(1,1,2), c(1,2,1))
c(1,1,2) == c(1,1,2)

typeof(all.equal(c(1,1,2), c(1,2,1)))
typeof((c(1,1,2) == c(1,1,2)))
```

***Dica:*** use `typeof` para entender.

##### D.6.8 - ***Desafio:*** Use `identical()` no lugar de `all.equal()` nos desafios anteriores. O que ela retorna? 

```{r, eval = FALSE, include = FALSE}
identical(t(t(listaQ6.7$H) %*% (listaQ6.7$J)), (listaQ6.7$J %*% listaQ6.7$H))

typeof(identical(t(t(listaQ6.7$H) %*% (listaQ6.7$J)), (listaQ6.7$J %*% listaQ6.7$H)))

a <- 1
identical(a, 1)
typeof(identical(a, 1))

identical(c(1,1,2), c(1,2,1))
typeof(identical(c(1,1,2), c(1,2,1)))
```


##### D.6.9 - ***Desafio:*** Olhe na documentação de `==` (lembre-se como usar o help para símbolos), `all.equal` e `identical`.

##### D.6.10 - ***Desafio:*** Qual é a diferença entre `==`, `all.equal` e `identical`? Você consegue pensar quando usar cada um deles?

```{r, include=FALSE, eval= FALSE}
print(" == é bom para você testar  valores em separado, célula a célula e não o vetor como um todo.")
print(" all.equal é bom para: medir a similaridade entre dois vetores. Além disso, ela tolera algum desvio eventual quando os argumentos são númericos. Assim, é bom para testar a igualdade com alguma margem de tolerância devido ao calculo númerico/arredondamento, e é bom também para se ter uma ideia do valor do desvio dos dois objetos. Porém, se você precisa usar o resultado lógico caso seja falso, será bem menos prático do que usar identical.")
print("identical testa se os dois objetos são identicos. Não importa o tamanho da diferença, se há alguma diferença em algum valor, o resultado será FALSE.")
```




## 7. A função diag

A função `diag()` é uma função muito relevante para Matrizes Insumo Produto. E ela é extremamente polivalente. Isso pode ser uma vantagem, porém pode ser perigoso se você não souber dela.

#### Q.7.1 Crie uma lista `listaQ7.1` tal qual: 
```{r, include= FALSE, eval = FALSE}
matrixZ <- matrix(c(4,2,3,1), nrow =2)
```
```{r, eval=FALSE}
listaQ7.1 <- list("Z" = matrixZ, "L1" = 2, "vector" = c(1, 3,5))
```
Com `matrixZ` sendo:
\begin{equation*}
Z = \begin{pmatrix}
4& 3\\
2& 1
\end{pmatrix}
\end{equation*}

#### Q.7.2 Use `diag()` em cada um dos elementos dessa matriz. O que foi retornado em cada caso?

#### Q.7.3 Você consegue entender o que aconteceu em cada caso? Entendeu o papel do argumento usado no resultado?
#### Q.7.4 Acesse a documentação de `diag`.


#### Q.7.5 Pela documentação de `diag`, se um objeto `G` da classe `matrix` tiver `names` associados aos seus valores, o que acontecerá com eles no caso de `diag(G)`?
#### Q.7.6 Leia a seção *Details* da documentação de `diag`. E tente enquadrar cada um dos 3 resultados da questão `Q.7.2` em um dos 4 apresentados.
#### Q.7.7 O que acontece quando fazemos `diag(2,3)`? E `diag(2,3,4)` e `diag(2,3,2)`? Qual dos 4 casos apresentados nós estamos tratando?

Criamos uma função, `l.diag` que crie irá criar uma diagonal com o mesmo `lenght` de um vetor atômico. 

```{r}
len.diag <- function(x){
  diag(length(x))
}

len.diag(c(1:3))
```

##### Q.7.8 -  Crie uma função `row.diag`, que irá criar uma matrix identidade quadrada com número de colunas e linhas igual a matrix usada de insumo.

```{r, eval = FALSE, include = FALSE}
row.diag <- function(x) diag(nrow(x))
```

## 8. Modelo de Leontief.

#### Q.8.1

Seja $A$ a matriz de coeficientes técnicos intersetorias.

\begin{equation*}
A = \begin{pmatrix}
0,3& 0,3 \\
0,2& 0,4
\end{pmatrix}
\end{equation*}

Estime a inversa de Leontief dessa matriz chamando-a de `inversa_81`. Pense em como usar a função `row.diag` neste caso. 

```{r, eval= FALSE, include = FALSE}
A <- matrix(c(0.3,0.2, 0.3, 0.4), nrow= 2)
inversa_81 <- solve(row.diag(A)- A)
```

#### Q.8.2 Crie uma função `inv.leontief` para gerar diretamente a inversa de Leontief.
```{r, eval= FALSE, include = FALSE}
inv.leontief <- function(x) solve(row.diag(x)- A)
```

#### Q.8.3 Crie uma matrix tal qual o vetor de demanda final, $y$, abaixo, e estime o produto usando a inversa de Leontief estimada em Q.8.1 (`inversa_L`). Nomeio-se de xQ8.3:

\begin{equation*}
y = \begin{pmatrix}
50 \\
10
\end{pmatrix}
\end{equation*}

```{r, eval=FALSE, include=FALSE}
y <- matrix(c(50,10), nrow = 2)
x_83 <- inversa_81 %*% y
```