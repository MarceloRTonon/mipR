---
title: "Tópico 5 - Lendo dados de forma automatizada"
author: "Marcelo Tonon e Felipe Cornelio"
date: "08/07/2020"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(eval = FALSE, include = TRUE)
# Todos os chunks em que estiver escrito "MT" quer dizer = Mensagem do Tonon. É um quadro dando dicas e etc... Use MF = Mensagem do Felipe.
```

## Pacotes Necessários

O pacote `stringr` a ser usado faz parte do núcleo do `tidyverse`.^[A essa altura do campeonato já consideramos que quem está lendo esse tópico já tem os pacotes do `tidyverse` instalados ou sabe como instalar caso não esteja. Ou seja, simplesmente fazer `install.packages("NomeDoPacote")`.]

```{r libraries, warning=FALSE}
library(tidyverse)
library(readxl)
library(openxlsx)
```


## Objetivos do Tópico

Feita a introdução de R, iremos neste tópico do curso apresentar as diferentes formas possíveis em que se pode ler uma base de dados a partir do R.

Para quem deseja se aprofundar mais no tema, o material desenvolvido aqui tem como principais referências os seguintes trabalhos:

 - Os tópicos [11](https://r4ds.had.co.nz/data-import.html) e [14](https://r4ds.had.co.nz/strings.html) do R for Data Science (R4DS).
 - O tópico [13](https://swcarpentry.github.io/r-novice-inflammation/13-supp-data-structures/index.html) do SW.
 
## Entrando a fundo nas funções paste e paste0

Se você deseja escrever uma frase no R a partir objetos, você pode usar a função `paste` ou a função `paste0`. Veja abaixo quando usamos a isso junto as funções `Sys.Date()` e `Sys.Time()`. que retornam, respectivamente, a data atual e o hórario atual. `paste` e `paste0` fazem no R o que `concatenar` faz no Excel.

```{r sysdate}
x <- "A data de hoje: "
data <- Sys.Date()
paste(x, data, sep = " ")
hora <- format(Sys.time(), "%X")
paste0("A hora é ", hora)
```

Repare que quando usamos `paste()` precisamos especificar qual será o separador entre os objetos concatenados com `sep = `. No caso de `paste(x, data, sep = " ")`, o separador é um dois pontos seguindo de um espaço, `": "`, como indicado entre as aspas. Importante dizer que o separador deve ser sempre um character. Assim sendo, uma função como `paste(x, data, sep = 2)` retornaria um erro.

No caso de `paste0()`, não há separador entre os objetos. Assim sendo, não há necessidade de estabelecer qual é o separador como `sep = ""`. Podemos pensar em `paste0()` como um subconjunto de `paste()`.

Aqui vale notar uma questão relevante, e de certo modo auto evidente, para as funções `Sys.time()` e `Sys.date`: ambas retornam valores diferentes quando executadas em diferentes momentos. Vamos ver as implicações então, quando criaremos o objeto `hora.1` e a função `hora()`:

```{r hora}

hora1 <-  paste0("A hora é: ", Sys.time())

# Pedindo para o R esperar 2 segundos.
Sys.sleep(2)


hora <- function() paste0("A hora é: ", Sys.time())

# Testando se o resultado de hora.1 e de hora.2() é a mesma coisa.
hora1 == hora()
```

Você pode perceber que quando perguntamos ao ``R`` se `hora1` e `hora()` são a mesma coisa, usando `==`, ele nos retorna `FALSE`. Isso porque, sempre que chamarmos `hora.1` no sistema, este irá retornar um mesmo valor, que foi gravado pela função `Sys.time()` no momento em que `hora1` foi definido. Por outro lado, a função `hora()` irá sempre retornar um valor novo toda vez que foi executada. Desse modo, ao usar funções ou objetos que tenham como insumo  funções como `paste` e `paste0`, temos que ter em mente se o valor do objeto é definido ou dinâmico.

```{r MT_note, eval = FALSE, include = FALSE}
Na lista de  exercicios 4, em questões para depois do dia 09/07/2020, vamos usamos Sys.time() junto com map() e for() para deixar ainda mais claro o contexto do que é uma função vetorizada.
```


## Strings no geral e no R

Vamos agora apresentar o que seria uma `string` e como isso se difere de um `character`. Em programação de modo geral, um "character" é somente o caracter isolado, por exemplo, a letra, um número, um símbolos, etc. Por sua vez, uma "string" é um conjunto de caracteres que podem, por exemplo formar uma palavra ou uma frase. Dentro de uma string podemos ter diversos caracteres (inclusive uma combinação de letras, numéricos ou símbolos). Uma forma comum de diferenciar `character` e `string` é usando aspas simples para caracteres (por exemplo, 'a') e aspas duplas para strings ("palavra ou frase").

No caso específico do R, não há diferenciação entre `character` e `string`, sendo todos objetos desse tipo sendo tratados como `character`. Ainda assim, é importante ter essa diferenciação na sua cabeça, para realizar tarefas que envolvam frases ou palavras.

```{r, eval=T}
# Se definirmos o que seria um character e string:

x <- 'a'
typeof(x)

```
```{r, eval=T}

y <- "Palavra ou Frase"
typeof(y)

```

Percebe-se que para ambos o tipo de é "character". Isso não traz nenhum problemas em específico, mas difere o R de alguma outras linguagens de programação. O R lê basicamente o que seria uma `string` como um conjunto de caracteres, o que não demandaria a criação de um novo tipo do objeto. Podemos, por exemplo, usar a função `nchar()` para contar quantos caracteres existem em um dado objeto.

```{r}
nchar(x)
```
```{r}
nchar(y)
```
Perceba que, o número de caracteres do que seria nossa `string` leva em conta o espaço entre as palavras. Qualquer elemento dentro das aspas será contabilizado como um caracter (exceto alguns especificos como a `/` não contam).


Uma observação importante é, ainda que não exista a distinção entre `character` e `string` no R, dentro do pacote `xtable` há uma função chamada `is.string()`, que é usada apenas no contexto de criação de tabelas tex a partir do R, mas que não tem influência no funcionamento geral da linguagem.

```{r MT_str_def, eval= FALSE, include = FALSE}
#Defina o que é uma string em termos gerais de programação. Procura na internet uma definição e tenta deixar ela mastigada, mas também sem dar muitas voltas. Não precisa definir string no contexto do R não logo de cara não, a definição pode ser ampla (e é até melhor se você conseguir). Um paragrafo falando disso. É melhor você definir primeiro num contexto geral, para então falar no R.

#Depois que você definir, fale no contexto do R (que não tem um tipo de dados chamados de strings por si só). Seria interessante você falar (mesmo que numa nota de rodapé) que existe uma função is.string() do pacote xtable (para produzir tabelas em tex) porém que na própria seção de Details da função diz que ela não deve ser usada em outro contexto. Assim, vale falar que no R não tem uma distinção entre strings e character. Que em outras linguagens é que há essa diferença (em muitas linguagens character se refere a letras individuais, enquanto string é um conjunto de characters).

#https://stackoverflow.com/questions/18513200/what-is-the-difference-between-string-and-character-in-r

#https://pediaa.com/what-is-the-difference-between-character-and-string/
```

### Quote com `"` e `'`

Para inserir uma string ou character no R podemos usar tanto aspas duplas " quanto aspas simples '. Ambos irão retornar o mesmo resultado, mas pode ser interessante você manter um padrão para separar o que são citações dentro de uma `string` do que a criação de uma `string`. No caso, conforme sugerido pelo Wickham no [R4DS](https://r4ds.had.co.nz/strings.html#string-basics), quando precisar inserir uma citação dentro de uma string é melhor criar a string com `'` e definir a citação com `"`: 

```{r, eval=FALSE}

string1 <- "Exemplo de String"
string2 <- 'Caso eu eu queira inserir uma "quote" usar aspas simples'

```

Caso você precise inserir uma aspas (simples ou dupla) sozinha dentro de uma string, é necessário incluir um `\` para que o R leia corretamente (caso contrário, ele vai tratar a terceira aspas como o início de uma nova `quote`). Outra opção é diferenciar aspas  simples e duplas:

```{r, eval=FALSE}

aspas_simples <- '\''
aspas_simples <- "'"
aspas_duplas <- "\""
aspas_duplas <- '"'

```


Dentro das quotes existem comandos para realizar operações especificas. Imagine que, por exemplo, você precise inserir uma quebra de linha dentro de uma string. Para fazer isso vc pode usar  o comando "newline" `\n` ou também dar um tab `\t`. Ou talvez, vc necessite de uma aspas interna para uma palavra do inglês (por exemplo, It's). Para ver uma lista com diversas operações dentro de quotes, basta analisar o help de `?quotes`. Por exemplo, temos:

```{r, eval=TRUE}
z <- '\tIt\'s important to study R in order to develop your\nskills in Input-Output Analysis\n\n\n(and also help you to get a job, if you need.)'
writeLines(z)
  
```

Para que o R leia corretamente o que vc deseja na frase, é necessário usar a função `writeLines()`.

```{r MT_quote, eval = FALSE, include = FALSE}
#Falar de "" e ''.

#Faça algo similar ao Strings Basics do R4DS ( https://r4ds.had.co.nz/strings.html#string-basics) sobre a necessidade de usar "" e '' e etc...

#Olhe em ?Quotes também.
```

Aqui entra um importante tema quando trabalhando com `strings` e `characters`: os caracteres especiais e os nomes não convencionais. Tratam de letras, símbolos e caracteres que não estão no escopo padrão da linguagem e em geral associoados a elementos de língua não-inglesa. Entrem aqui, por exemplo, elementos do alfabeto grego.

```{r}
mi <- "\u03bc"
mi
```
```{r}
theta <- "\u03b8"
theta
```
```{r}
Delta <- "\u0394"
Delta
```

Você pode buscar as correspondências do `unicodes` para cada letra grega que desejar. Essa lista está acessível na internet e os códigos, em geral, são universais.

### Nomes Impossíveis e Nomes Reservados



Outra importante questão são os nomes reservados e que não podem ser usados como nomes de objetos. 

```{r MT_reserved, eval = FALSE, include = FALSE}
#Falar dos nomes reservados e sobre os nomes não convencionais. Importante você deixar claro que não é para sair definindo objetos com esses nomes, mesmo tendo como fazer isso. Fale que é para deixar reservado isso para nomes de elementos listas. 

# Para te ajudar nisso tudo , vale você dar uma olhada no R Documentation "?Reserved", 


#Exemplos:

# TRUE <- "impossível pois o R não deixa"
# Fale como F e T são "apelidos" de FALSE e TRUE.

# Coloque no meio disso tudo o chunck lista_reservados.

# Fale do que deixa nome impossível (espaço, parenteses, aspas e etc) Veja mais sobre em: https://adv-r.hadley.nz/names-values.html#non-syntactic



# Fale como se pode burlar as impossibilidades
# `TRUE` <- paste("truly", "chaotic", "evil", sep = " ")
# `2000` <- "PESSIMO"
#"df$`2000`$AUS" <- "ACEITÁVEL"

# `x y` <- "dez anos de gulag"
# T <- "passível de fuzilamento"


#Fale também sobre as boas práticas de não criar objetos com nomes já usados. 

#c <- c(1:4)
#matrix <- matrix(c(1:4), nrow = 2)
#t <- t(matrix(c(1:4), nrow =2))
# sum <- function(x,y) rbind(x,y)

# Fale do risco disso criar uma mega confusão ao longo do código e para o computador.
```

Lista de nomes reservados
```{r lista_reservados, eval= FALSE, include = TRUE}
if else repeat while function for in next break

TRUE FALSE NULL Inf NaN NA NA_integer_ NA_real_ NA_complex_ NA_character_
```


### Criando nomes legitimos

```{r MT_makenames, eval = FALSE, include = FALSE}
#mostre os exemplos de você transformando nomes ruins em nomes legitimos com a função make.names (veja ?make.names)

# make.names(TRUE)
# make.names(NA)
# make.names("NA")
# make.names(2000)
# make.names("_A")
# make.names("x y")

## Em suma oque acontece com cada um:
# make.names("nomevalido")
# make.names("_nome invalido")
# Mas chame a atenção para o fato de que podendo, é sempre melhor evitar dar nomes a objetos do Global Environment que precise de make.names(). Mas fale, que em data.frame(..., check.names = TRUE) os nomes das colunas passam por make.names()

```


## O pacote stringr


```{r MT_base_de_dados, eval = FALSE, include = FALSE}
#Procure uma base de dados que tenha muitos nomes... Os exemplos de stringr na cheatsheet do RStudio (está na pasta Top5) são todos usando a base fruit. Vale você usar ela para você aprender o que cada função do pacote faz e funciona, PORÈM lembre que não é para usar ela para evitar problemas de copyright. 

#Dica: Na falta de algo melhor, dentro do próprio pacote datasets tem uma base de dados que pode ser interessante: "USJudgeRatings". Apresenta a função "tibble::rownames_to_column()" para transformar os nomes das linhas numa coluna. .
  
# Se você quiser, pode fazer uma base própria usando paste e paste0.

# Dica: Se você fizer:

#df_vignette <- vignette(all= TRUE)[[4]] %>% as.data.frame

#você tem aí um belo data.frame só com strings para você brincar. Se você não quiser fazer isso na parte expositiva, é uma boa ideia para a lista de exercicios. Só vale dizer que vai ser diferente para cada usuário, uma vez que cada um instalou pacotes diferentes.
```

```{r MT_stringr, eval = FALSE, include = FALSE}
# Decidida a base de dados que você vai usar, aplique nela os exemplos presentes na página 1 do cheatsheet. 

# Dica, use o help em todas as funções. Explique na primeira os argumentos que aparecem nela "str_detect(string, pattern, negate = FALSE)" (sempre mostra a função assim como tá em usage)  e explica o que cada um quer dizer. Aí você segue nas seguintes funções só falando os argumentos que mudarem.

#Veja o exemplo abaixo na seção "#### Usando ``stringr` para detectar padrões"
```

#### Usando ``stringr` para detectar padrões

O pacote `stringr` pode te ajudar a encontrar padrões em strings e blá blá blá. 

A função `str_detect` serve para ***isso***. Ela devolve um vetor de tipo ***aquilo***.

```{r MT_str_detect_formals, eval = FALSE}
str_detect(string, pattern, negate = FALSE)
```

O argumento `string` se refere à string que você vai usar. `pattern` se refere a qual padrão a ser analisado pela função. Já `negate` ***diz tal coisa*** e tem como valor padrão `FALSE`. Se for `TRUE`, acontece ***sei lá oque***.

```{r str_detect_uso}
# Supondo que vamos usar df_vignette
dfvignette <- vignette() %>% .[[4]] %>% as.data.frame()

#Queremos saber que linhas da 4 coluna tem ou não um arquivo em html.

htmlDetect <- str_detect(dfvignette[,4], pattern = "html")

# Usando negate = TRUE

htmlReject <-  str_detect(dfvignette[,4], pattern = "html", negate = TRUE)
```

Isso pode ser util se quisermos fazer um subsetting tal qual:

```{r str_detect_utilidade}
dfvignette_html <- dfvignette[htmlDetect,]
```



```{r MT_stringr_final, eval = FALSE, include =FALSE}
#Vá falando das funções de `stringr` nesse nível. Se você precisar de inspiração nas explicações pega o capítulo disso no R4DS e as vignettes de R.

#Da segunda página do cheatsheet fala só a parte que tem "need to know".

#### MUITO RELEVANTE: Fale de "$", que quando você quando for usar str_subset e um dos valores tiver "$" no meio do nome, não bastará usar pattern = "$", nem "\$". Deve ser "\\$".
```

```{r MT_stringi, eval = FALSE, include =FALSE}
#Não precisa entrar em nada de regex ou nada especifico do stringi. Vamos deixar isso para um tópico suplementar mais a frente se necessário.
```


## Lendo vários arquivos usando função `list.files`


```{r MT_listfiles, eval = FALSE, include = FALSE}
#Fale da função list.files primeiro em abstrato.

#Depois, crie, a partir das bases dentro datasets do R, uma série de arquivos xlsx com openxlsx::write.xlsx. Coloque todos numa pasta x.

#Usa list.files() na pasta.

xfiles <- list.files("x")

#Leia então usando map. Importante o as.list()

arquivos <- xfiles %>%
  as.list() %>%
  map(read_xls)
```

Coloque então na pasta um arquivo em csv. Dê um exemplo usando `list.files()` com `str_subset(negate = TRUE)`para tirar esse arquivo do vetor.

Fale então para o usuário abrir um dos arquivos de excel fora do R. A depender do software usado é possível que o sistema operacional podem gerar um arquivo com `$` na frente (isso ocorre especialmente quando o arquivo veio zipado). Esse arquivo pode estar oculto quando você entra na pasta inclusive. Relembre então de `\\$`! (Qualquer coisa, usa o paste0 mesmo para dizer essa parte.)

## Descompactando arquivos.

Funções `zip`, `unz`, `unzip`, `unzip(..., list = TRUE)` e `unzip(..., files = c("", ""))`.

Brinca com os arquivos que você criou para lidar com isso e etc... Mostra como fazer uma sequência para importar arquivos pro R e etc... Usa `str_sub()` para criar o nome dos objetos e etc... 


## Abordando download.file

Isso daqui no futuro a gente coloca no Tópico 2.

Fala da função download.file. Fala da questão de dados binários ou não precisa ser `mode= wb` e etc...

Já que o ibge é um porre conseguir o link direto para o download, faz pra NIOT mesmo... Não precisa baixar o zip de todos os páises via o R (já que ele é imenso e só faz em primeiro plano). Baixa algum outro, mas explica a função por parte. Fala também da questão dos arquivos e diretórios temporarios e etc...

